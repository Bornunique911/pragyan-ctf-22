from base64 import b64decode


def is_prime(n):
    if n == 1:
        return False 
    if n % 2 == 0:
        return n == 2
    
    i = 3

    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
        
    return True 


def get_nth_prime(n):
    # get nth prime starting with index 0
    
    i = -1
    j = 0
    
    while i != n:
        j += 1
        
        if (is_prime(j)):
            i += 1
    
    return j


def unchange(n):
    right = n & 0xf
    left = n >> 4
    
    return (right << 4) + left


def is_armstrong(n):
    num = n
    digits = len(str(n))
    total = 0

    while num != 0:
        val = num % 10
        total += int(val ** digits)

        num //= 10

    return total == n 


def reverse_shuffle(n):
    
    # This function devides given 64 bit number
    # into 8, 8 bit pieces then it does xor with 
    # array of length 8, but if position of the byte (piece) 
    # in that number is equal to index of that array it skips
    # so in total 7 xor occur then it contruct the new number
    # from those bytes (that are xored) by putting them in reverse order


    # Array that is used in this function
    A = [
        67,
        131,
        37,
        59,
        193,
        71,
        107,
        233,
    ]
    
    new_num = 0
    
    for i in range(8):
        # get last 8 bits
        bits = n & 0xff
        
        # shift n for next iteration
        n = (n >> 8)
        
        for j in range(8):
            # in program it checks if both index are equal then skip
            # but since after applying changes bytes will be stored 
            # in reverse order, we will be checking if index are counter part or not
            
            if i == 7 - j:
                continue
            
            bits = bits ^ A[j]
        
        # adding the number in reverse order
        # lsb will become msb
        new_num = (new_num << 8) + bits

    return new_num


def reverse_check1():
    # number has exactly 45 bit since shifting it 44 bit right lefts only 1
    length = 45
    
    # xor with 0x7fff will give last 15 bits
    # last 15 bit xor 0x1afc == 0x5ca3
    last_15_bits = 0x5ca3 ^ 0x1afc
    
    # getting the first 9 bits
    # shifting 36 bit right will give first 9 bits and
    # first_9_bits xor 0x53e == 0x4a7
    first_9_bits = 0x4a7 ^ 0x53e

    # then there is check on the number 
    # by check_num_1 function and check_num_2 function 
    # check_num_1 function checks if the number is prime or not
    # check_num_2 function checks if the number is armstrong or not
        
    # brute forcing rest of the bits
    # we can simply bruteforce rest of the 21 bits (45 - 15 - 9 = 21 => 2 ** 21 possibilities)
    
    i = 0
    
    while i < int(2 ** 21):
        intermediate_bits = (i << 15) # since they are after 15 bits of lsb
        num = (first_9_bits << 36) + intermediate_bits + last_15_bits
        
        if is_armstrong(num) and is_prime(num):
            return num 
        
        i += 1


def reverse_check2():
    # srand as seed 0x8a1b791f
    # we are taking rand() % 0xff for first 6 rand call
    # this code can generate those random numbers in c
    """
    #include <stdio.h>
    #include <stdlib.h>
    
    int main(void) {
        srand(0x8a1b791f);
        for (int i = 0; i < 6; ++i) {
            printf("%u\n", rand() % 0xff);
        }
        return 0;
    }
    """
    
    random_nums = [
        224,
        138,
        111,
        45,
        91,
        25,
    ]
    
    # function adds number one next to other
    n = 0
    
    for number in random_nums:
        n = (n << 8) + number

    # shuffling the input number gives `n`
    # so reverse shuffling should give input number
    return reverse_shuffle(n)
    

def reverse_check3():
    # check3 function calls the conv function
    # which just takes string and return base64 encoded string
    # and compares the encoded string to `str` variable available in global scope
    
    # str variable which is encoded version of out input
    str_variable = "TWM1THlGN1l2SXhMeGVUWA=="

    return b64decode(str_variable).decode('utf-8')


def reverse_check4():
    # this check has bunch of condition that define the input string
    
    # first check is length of string which is 16
    string = [ 0 for i in range(16) ]
    
    # if string[0] ^ 0x53 == 0
    string[0] = 0x53
    
    # if string[0] ^ string[15] == 0x7
    string[15] = string[0] ^ 0x7
    
    # string[7] & string[4] == string[7] and string[7] & string[4] = string[7]
    # means string[7] == string[4]
    
    # string[7] & 0xf == string[0] & 0xf
    # last four bits of string[7] == last four bits of string[0]
    string[7] = string[0] & 0xf
    string[4] = string[0] & 0xf
    
    # (string[4] & 0xf0) & 0x60 == 0x60 && string[4] >> 7 == 0
    # first four bits of string[4] is 0x6
    string[7] += 0x60
    string[4] += 0x60
    
    # string[4] ^ string[6] == 0x8
    string[6] = string[4] ^ 0x8
    
    # string[6] - string[3] == 0x3
    string[3] = string[6] - 0x3
    
    # string[8] == (string[11] >> 1)
    
    # string[11] == 102
    
    string[11] = 102
    
    string[8] = (string[11] >> 1)
    
    # (string[10] >> 3 == 0xf) && (string[10] & 0x7) == (string[3] & 0x7)
    
    string[10] = (0xf << 3) + (string[3] & 0x7)
    
    # (string[1]) * string[13]) == 6059 && string[13] > string[1]
    # 6059 has only three factor
    # 1 x 6059
    # 73 x 83
    # 6059 x 1
    
    # here first and last are invalid since number are too big for char
    string[13] = 83
    string[1] = 73
    
    
    # string[14] ^ 0x44 == 0
    string[14] = 0 ^ 0x44
    
    # string[12] ^ string[14] == 0x30
    string[12] = string[14] ^ 0x30
    
    # string[2] == toupper('z')
    string[2] = ord('z'.upper())
    
    # string[5] ^ 0x3e == 0x7f
    string[5] = 0x3e ^ 0x7f
    
    # string[9] - string[14] == 0x8
    string[9] = 0x8 + string[14]
    
    return "".join([chr(i) for i in string])


def reverse_check5():
    # check5 function make array (say A) of 6 element 
    # and set their value by dividing 48 bit input number 
    # into 6 part of 8 bits, 8 lsb goes to index 0 and so on
    # while assigning value it does xor between number of array with
    # `get(V[i] & 0xff)` where V[i] is array defined there
    # and finaly A[i] = change(A[i])
    # then it adds those number in same order 
    # (A[0] >> 40) + (A[1] >> 32) .. (A[5])
    # to generate number and its checked with 0xa8f24130a1ef
    
    final_num = 0xa8f24130a1ef

    original = 0
    A = [0] * 6
    
    vals = [
        103,
        127,
        157,
        11,
        29,
        211
    ]
    
    # getting array A by applying mentioned processes in reverse order
    for i in range(6):
        val = final_num & 0xff
        final_num >>= 8
        
        A[i] = val
        
        # in program there is A[i] = A[i] ^ get(vals[i])
        # then there is A[i] = change(A[i])
        # performing these action in reverse order
        A[i] = unchange(A[i])
        A[i] = A[i] ^ (get_nth_prime(vals[i]) & 0xff)
        
        
    # generate original number
    for i in range(6):
        original = (original << 8) + A[5 - i]
        
    return original


def reverse_flag(str1, str2, int1, int2, int3):
    # array used used in `check_flag`
    # applying operation occured in reverse order will get flag

    info = [
        251,
        44,
        37,
        190,
        167,
        199,
        136,
        182,
        50,
        36,
        36,
        8,
        51,
        117,
        49,
        59,
        212,
        185,
        18,
        198,
        154,
        109,
        182,
        35,
        39,
        139,
        199,
        133,
        207,
        252,
        50,
        199,
    ]

    for i in range(32):
        val = 0
        
        if i < 8:
            val = int1 & 0xff
            int1 >>= 8
        elif i >= 8 and i < 16:
            val = int2 & 0xff
            int2 >>= 8
        elif i >= 16 and i < 24:
            val = int3 & 0xff
            int3 >>= 8
        else:
            val = 0xff

        info[i] = info[i] ^ val
    
    
    for i in range(32):
        
        if i % 2 == 0:
            info[i] = info[i] ^ unchange(ord(str1[i // 2]))
        else:
            info[i] = info[i] ^ unchange(ord(str2[(i - 1) // 2]))
    
    return "".join(chr(i) for i in info)

int1 = reverse_check1()
int2 = reverse_check2()
str1 = reverse_check3()
str2 = reverse_check4()
int3 = reverse_check5()

print(reverse_flag(str1, str2, int1, int2, int3))
